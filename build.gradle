buildscript {
    repositories {
        google()
        jcenter()
    }
    dependencies {
        /**
         * Dependencies to support bintray upload
         */
        classpath 'com.github.dcendents:android-maven-gradle-plugin:2.0'
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.4'

        /**
         * Be careful at upgrading to higher version of gradle (e.g., > 3.0):
         * Compilation may work but application will have error when executed due to AAPT2 exception.
         * Disabling AAPT2 will hide an issue with AAPT2 and may cause to stop unit tests to work.
         * Please update only after either the issue is fixed on Android side or fix the bug in the project for AAPT2.
         * https://issuetracker.google.com/issues/38454212
         * https://github.com/requery/requery/issues/467
         */
        classpath 'com.android.tools.build:gradle:3.4.1'
    }
}

plugins {
    // Google Java Format Plugin:
    // 1. Run `gradlew goJF` to format source codes
    // 2. Run `gradlew verGJF` to verify code farmat
    // 3. More usage information can be found at
    // https://github.com/sherter/google-java-format-gradle-plugin
    id 'com.github.sherter.google-java-format' version '0.8'
}

subprojects {
    repositories {
        mavenCentral()
        jcenter()
        google()
    }
    apply plugin: 'maven'
    apply plugin: 'maven-publish'
    apply plugin: 'com.jfrog.bintray'
    apply plugin: 'java'

    apply plugin: 'com.github.sherter.google-java-format'

    // Bintray Configurations:
    // 1. Env variable BINTRAY_USER and BINTRAY_API_KEY must be set
    // properly in order to enable bintray upload. Information can
    // be found in pinned messages in #dcap slack channel.
    // 2. Run "gradlew --info bintrayUpload" in project dir to upload
    // jar file. For example, to upload amino-run-core.jar, you need to
    // run "gradlew --info bintrayUpload" in core project.
    // 3. If you modified amino-run-core.jar without bumping up the
    // package version, then you need to remind developers to clean 
    // old versions from gradle cache by running $(rm -rf ~/.gradle/caches).
    bintray {
        user = project.hasProperty('bintrayUser') ? project.property('bintrayUser') : System.getenv('BINTRAY_USER')
        key = project.hasProperty('bintrayApiKey') ? project.property('bintrayApiKey') : System.getenv('BINTRAY_API_KEY')
        configurations = ['archives']

        publications = ['Production']
        override = true
        pkg {
            dryRun = false
            publish = true
            repo = project.property('bintrayRepo')
            name = project.property('bintrayPkgName')
            licenses = [project.property('bintrayLicense')]
            vcsUrl = project.property('bintrayVcsUrl')
            version {
                name = project.property('bintrayVersion')
            }
        }
    }

    // Maven Configurations
    publishing {
        publications {
            Production(MavenPublication) {
                groupId project.property('mavenGroupId')
                artifactId project.property('mavenArtifactId')
                version project.property('mavenVersion')

                pom.withXml {
                    def dependenciesNode = asNode().appendNode('dependencies')
                    // Iterate over the implementation dependencies (we don't want the test ones), adding a <dependency> node for each
                    configurations.implementation.allDependencies.each {
                         //Ensure dependencies such as fileTree are not included in the pom.
                        if (it.name != 'unspecified') {
                            def dependencyNode = dependenciesNode.appendNode('dependency')
                            dependencyNode.appendNode('groupId', it.group)
                            dependencyNode.appendNode('artifactId', it.name)
                            dependencyNode.appendNode('version', it.version)
                        }
                    }
                }
            }
        }
    }

    // Common rules for all JavaExec tasks, being added before execution.
    tasks.withType(JavaExec).whenTaskAdded {
        classpath += sourceSets.main.runtimeClasspath
    }

    def getJdkVersion = { ->
        def javaErrOut = new PipedOutputStream()
        def grepIn = new PipedInputStream(javaErrOut)
        def grepOut = new PipedOutputStream()
        def awkIn = new PipedInputStream(grepOut)
        def awkOut = new ByteArrayOutputStream()
        def jdk6path = project.property('jdk6Path')
        exec {
            workingDir jdk6path + '/jre/bin'
            commandLine './java', '-version'
            errorOutput = javaErrOut
        }
        exec {
            commandLine 'grep', 'version'
            standardInput = grepIn
            standardOutput = grepOut
        }
        exec {
            commandLine 'awk', '{print $3}'
            standardInput = awkIn
            standardOutput = awkOut
        }
        return awkOut.toString().trim()
    }

    // Added for enforcing Java 1.6 version compatibility.
    tasks.withType(JavaCompile) {
        def jdk6path = project.property('jdk6Path')
        def jdkFolder = new File(jdk6path +"/jre")
        if(!jdkFolder.exists()) {
            throw new GradleException("JDK 1.6 path is not set. Please set 'jdk6Path' project property in gradle.properties file")
        }

        //Check whether jdk is 1.6 or not
        def jdkVersion =  getJdkVersion()
        if(!jdkVersion.contains("1.6")) {
            throw new GradleException("jdk6Path project property is set with JDK '" + jdkVersion.substring(1, 4) + "' path. Please set it with JDK 1.6 path.")
        }

        sourceCompatibility = JavaVersion.VERSION_1_6
        targetCompatibility = JavaVersion.VERSION_1_6
        options.fork = true
        options.bootstrapClasspath = files(jdk6path + "/jre/lib/rt.jar")
    }

    // SourceSet for generated stubs
    sourceSets {
        stubs
    }

    // Task for Stub Generation:
    // Run `gradlew genStubs` to generate stub files
    task genStubs(type: JavaExec) {
        main = "amino.run.compiler.StubGenerator"
    }

    // Configure "stubs" sourceSet compile task, with additional rules.
    compileStubsJava {
        classpath += sourceSets.main.runtimeClasspath
        options.incremental = true
        dependsOn genStubs
    }

    clean {
        delete genStubs.outputs.files // Add generated stubs to what the clean task must delete
        doLast {
            logger.info('Clean will delete ' + clean.targetFiles.asCollection())
        }
    }

    /*
        jar
        Depends on: classes
        Assembles the production JAR file, based on the classes and resources attached to the main
        source set.
    */
    jar {
        // Also include stubs sourceSet classes in the jar file.
        from sourceSets.stubs.output.classesDirs
    }

    googleJavaFormat {
        options style: 'AOSP'
        exclude '**/*_Stub.java'  // Don't reformat autogenerated stubs, otherwise they look out of
        // date and get regenerated and reformatted again and again.
    }

    tasks.googleJavaFormat.dependsOn tasks.withType(AbstractCompile)
    check.dependsOn tasks.googleJavaFormat

    check.dependsOn tasks.withType(AbstractCompile)  // Ensure that all compileTasks are executed, as part of check.
}
